<!DOCTYPE html>
<!-- _layouts/distill.html --><html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    
    <!-- Website verification -->
    <meta name="google-site-verification" content="1BWHOhCt_eijp5wvU_9Cvh591AfMs_im4cOLhN3wkP4">
<!-- Avoid warning on Google Chrome
        Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'interest-cohort'.
        see https://stackoverflow.com/a/75119417
    -->
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()">

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Chọn ngẫu nhiên điểm trong hình tròn | The-Anh Vu-Le (Nah)</title>
    <meta name="author" content="The-Anh  Vu-Le">
    <meta name="description" content="a fake trying to be real
">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%90%96&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://vltanh.github.io//blog/2022/ngau-nhien-hinh-tron/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    


    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Distill js -->
    <script src="/assets/js/distillpub/template.v2.js"></script>
    <script src="/assets/js/distillpub/transforms.v2.js"></script>
    <script src="/assets/js/distillpub/overrides.js"></script>
    
  </head>

  <body>
<d-front-matter>
    <script async type="text/json">{
      "title": "Chọn ngẫu nhiên điểm trong hình tròn",
      "description": "",
      "published": "March 23, 2022",
      "authors": [
        {
          "author": "The-Anh Vu-Le",
          "authorURL": "",
          "affiliations": [
            {
              "name": "",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/">The-Anh Vu-Le (Nah)</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/repositories/">repositories</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">cv</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="post distill">

      <d-title>
        <h1>Chọn ngẫu nhiên điểm trong hình tròn</h1>
        <p></p>
      </d-title>

      <d-byline></d-byline>

      <d-article>
        <d-contents>
          <nav class="l-text figcaption">
          <h3>Contents</h3>
            <div><a href="#c%C3%A2u-h%E1%BB%8Fi">Câu hỏi</a></div>
            <div><a href="#ti%E1%BA%BFp-c%E1%BA%ADn">Tiếp cận</a></div>
            <ul>
              <li><a href="#c%C3%A1ch-kh%C3%B4ng-%C4%91%C3%BAng">Cách không đúng</a></li>
              <li><a href="#l%E1%BA%A5y-m%E1%BA%ABu-ngh%E1%BB%8Bch-%C4%91%E1%BA%A3o">Lấy mẫu nghịch đảo</a></li>
              <li><a href="#l%E1%BA%A5y-m%E1%BA%ABu-t%E1%BB%AB-ch%E1%BB%91i">Lấy mẫu từ chối</a></li>
              
            </ul>
          </nav>
        </d-contents>

        <h2 id="câu-hỏi">Câu hỏi</h2>

<p>Làm thế nào để chọn ngẫu nhiêu đều một điểm trong hình tròn?</p>

<h2 id="tiếp-cận">Tiếp cận</h2>

<p>Không mất tính tổng quát, xét hình tròn tâm \(O(0, 0)\), bán kính \(R = 1\). Ta cần sinh điểm ngẫu nhiên thỏa yêu cầu đề bài.</p>

<h3 id="cách-không-đúng">Cách không đúng</h3>

<p>Một cách ngây thơ, sẽ có người nghĩ đến việc sinh ngẫu nhiên trong hệ tọa độ cực trước bằng cách xét hai biến ngẫu nhiên</p>

<ul>
  <li>\(D\): khoảng cách đến tâm hình tròn, phân bố đều trên \([0, 1]\), hay \(D \sim U(0, 1)\),</li>
  <li>\(\Theta\): góc giữa \(\vec{OA}\) và \(\vec{Ox}\), phân bố đều trên \([0, 2\pi]\), hay \(\Theta \sim U(0, 2\pi)\).</li>
</ul>

<p>Từ đó, hoành độ \(X\) và tung độ \(Y\) (là hai biến ngẫu nhiên) có thể tính được dựa trên công thức biến đổi từ hệ tọa độ cực sang hệ tọa độ Oxy:</p>

\[X = D \cos \Theta, \;\; Y = D \sin \Theta.\]

<p>Mã nguồn Python cho phương pháp này là như sau</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gen1</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="c1"># Random samples d's from U(0, 1)
</span>    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    
    <span class="c1"># Random samples theta's from U(0, 2 * pi)
</span>    <span class="n">Theta</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span>
    
    <span class="c1"># Transformation from polar to Cartesian coordinates
</span>    <span class="n">X</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">Theta</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">Theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>
</code></pre></div></div>

<p>Làm theo cách này, kết quả thu được sẽ như hình dưới (\(N = 5000\)).</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/2022-03-24_images/gen1-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/2022-03-24_images/gen1-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/2022-03-24_images/gen1-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/2022-03-24_images/gen1.png" class="img-fluid" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

<p>Nếu để ý kỹ, mọi người sẽ nhận ra có một vấn đề với cách tiếp cận này: Có vẻ như là các điểm được chọn co cụm về tâm nhiều hơn.</p>

<p>Tại sao lại có hiện tượng này? Rõ ràng là chúng ta đã chọn khoảng cách đến tâm là một phân bố đều rồi mà. Đổi góc nhìn một chút, hãy thử xét ví dụ thế này: Xét hai vùng A và B tương ứng là vùng chứa các điểm có khoảng cách đén tâm hình tròn là \([0.1, 0.2]\) và \([0.8, 0.9]\). Xác suất điểm được chọn đến từng vùng A và vùng B đều là \(0.1 = P(0.1 \leq D \leq 0.2) = P(0.8 \leq D \leq 0.9)\). Tuy nhiên, diện tích của vùng A là \(\pi 0.2^2 - \pi 0.1^2 = 0.03\pi\), nhỏ hơn nhiều so với \(0.17\pi\) của vùng B. Nói cách khác, vùng A gần tâm hơn, diện tích nhỏ hơn, nhưng lại có cùng xác suất điểm được chọn rơi vào so với vùng B. Nói cách khác, điểm được chọn có xác suất rơi vào hai vùng là như nhau, nhưng do vùng A có diện tích bé hơn nên mật độ điểm ở đây dày đặc hơn vùng B.</p>

<p>Cụ thể hơn, ta có hàm mật độ</p>

\[f_{(D, \Theta)}(d, \theta) = f_D(d)f_\Theta(\theta) = \left\{
    \begin{array}{ll}
        \dfrac{1}{2\pi} &amp; d \in [0, 1], \theta \in [0, 2\pi) \\
        0 &amp; \text{khác}
    \end{array}
    \right. .\]

<p>Trong đó, dấu \(=\) đầu tiên là do \(R\) và \(\Theta\) độc lập với nhau.</p>

<p>Sử dụng công thức đổi biến với công thức biến đổi hệ tọa độ, ta có</p>

\[f_{(X, Y)}(x, y)
    = f_{(D, \Theta)}(d, \theta) \left|
    \begin{array}{cc}
        \dfrac{\partial x}{\partial d} &amp; \dfrac{\partial x}{\partial \theta} \\
        \dfrac{\partial y}{\partial d} &amp; \dfrac{\partial y}{\partial \theta}
    \end{array}
    \right|^{-1}
    = f_{(D, \Theta)}(d, \theta) \left|
    \begin{array}{cc}
        \cos \theta &amp; -d \sin \theta \\
        \sin \theta &amp; d \cos \theta
    \end{array}
    \right|^{-1}\]

\[= \dfrac{1}{d} f_{(D, \Theta)}(d, \theta)
    = \left\{
    \begin{array}{ll}
        \dfrac{1}{2\pi \sqrt{x^2 + y^2}} &amp; x^2 + y^2 \leq 1 \\
        0 &amp; \text{khác}
    \end{array}
    \right. .\]

<p>Có thể thấy mật độ điểm được chọn sẽ giảm đi khi càng ra xa tâm hình tròn (\(x^2 + y^2\) càng lớn). Ngoài ra, cũng có thể thấy rõ là cách tiếp cận này không thỏa yêu cầu bài toán, vốn yêu cầu hàm mật độ phải là \(\pi^{-1}\) bên trong hình tròn.</p>

<h3 id="lấy-mẫu-nghịch-đảo">Lấy mẫu nghịch đảo</h3>

<p>Đến đây, có thể mọi người đã định hình một số cách tiếp cận trong đầu rồi. Mấu chốt ở đây là chúng ta không thể lấy phân bố \(R\), hay khoảng cách đến tâm, một cách đều trên \([0, 1]\) được, mà những điểm ở xa tâm sẽ phải được “ưu ái” hơn để cân bằng với phần diện tích.</p>

<p>Cụ thể, một cách trực quan, ta có</p>

\[F_D(d) = P(D \leq d)
    = \left\{
    \begin{array}{ll}
        0 &amp; d &lt; 0 \\
        \dfrac{\pi d^2}{\pi R^2} &amp; 0 \leq d &lt; R\\
        1 &amp; 1 \leq d
    \end{array}
    \right.
    = \left\{
    \begin{array}{ll}
        0 &amp; d &lt; 0 \\
        d^2 &amp; 0 \leq d \leq 1\\
        1 &amp; 1 &lt; d
    \end{array}
    \right. .\]

<p>Như vậy, hàm mật độ của $D$ sẽ là</p>

\[f_D(d)
    = \left\{
    \begin{array}{ll}
        2d &amp; 0 \leq d \leq 1 \\
        0 &amp; \text{khác}
    \end{array}
    \right. .\]

<p>Ở đây, nhận xét \(P(D \leq d)\) bằng tỉ lệ diện tích hai hình tròn đồng tâm bán kính $d$ và $R$ thực chất là một nhận xét cảm tính. Ta cũng sẽ đi đến kết luận tương tự khi xét</p>

\[f_D(d)
    = \dfrac{f_{(D, \Theta)}(d, \theta)}{f_\Theta(\theta)}
    = d \dfrac{f_{(X, Y)}(x, y)}{f_\Theta(\theta)}
    = \left\{
    \begin{array}{ll}
        d \dfrac{1}{\pi} 2\pi &amp; 0 \leq d \leq 1 \\
        0 &amp; \text{khác}
    \end{array}
    \right. .\]

<p>Câu hỏi được đặt ra bây giờ là: làm sao để lấy mẫu ngẫu nhiên từ phân bố của \(D\) được mô tả ở trên? Ở đây, hàm phân bố tích lũy của phân bố này có một tính chất đặc biệt: nó khả nghịch trên \([0, 1]\). Cụ thể, nghịch đảo của nó trên đoạn này là</p>

\[F_D^{-1}(y) = \sqrt{F_D(y)}\]

<p>Do đó, ta có thể ứng dụng phương pháp lấy mẫu như sau (thường gọi là lấy mẫu nghịch đảo, inverse sampling):</p>

<ol>
  <li>Lấy ngẫu nhiên $v$ từ \(U(0, 1)\)</li>
  <li>Tính \(d = F_D^{-1}(v) = \sqrt{F_D(v)}\), đây chính là giá trị cần tìm</li>
</ol>

<p>Tại sao phương pháp này lại hoạt động? Xét \(V \sim U(0, 1)\) và \(T = F_{D}^{-1}(V)\). Với mọi \(t\), có</p>

\[F_T(t) = P(T \leq t) = P(F_{D}^{-1}(V) \leq t) = P(V \leq F_{D}(t)) = F_{V}(F_{D}(t)) = F_D(t)\]

<p>Do đó, \(D\) và \(T = F_{D}^{-1}(V)\) có cùng phân bố.</p>

<p>Mã nguồn Python của cách tiếp cận này là như sau:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gen2</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="c1"># Random sample v's from U(0, 1)
</span>    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="c1"># Calculate F_D^{-1}(v)
</span>    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    
    <span class="c1"># Random samples theta's from U(0, 2 * pi)
</span>    <span class="n">Theta</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span>
    
    <span class="c1"># Transformation from polar to Cartesian coordinates
</span>    <span class="n">X</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">Theta</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">Theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span>
</code></pre></div></div>

<p>Kết quả thu được như hình bên dưới (\(N = 5000\)).</p>

<figure>

  <picture>
    
    <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/2022-03-24_images/gen2-480.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/2022-03-24_images/gen2-800.webp"></source>
    <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/2022-03-24_images/gen2-1400.webp"></source>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/2022-03-24_images/gen2.png" class="img-fluid" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">

  </picture>

</figure>

<h3 id="lấy-mẫu-từ-chối">Lấy mẫu từ chối</h3>

<p>Phần này xin chỉ ra một cách tiếp cận theo tư tưởng lấy mẫu từ chối (rejection sampling). Ý tưởng ở đây rất đơn giản:</p>

<ol>
  <li>Lấy ngẫu nhiên \(x, y\) từ \(U(-1, 1)\)</li>
  <li>Nếu \(x^2 + y^2 \leq 1\) (nằm trong hình tròn), ta nhận điểm đó. Ngược lại, lặp lại từ Bước 1.</li>
</ol>

<p>Mã nguồn Python của cách tiếp cận này như sau (đã có thay đổi nhằm tăng tốc độ).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gen3</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
     <span class="n">points</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
     <span class="n">accepted</span> <span class="o">=</span> <span class="p">((</span><span class="n">points</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
     <span class="k">while</span> <span class="n">accepted</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
         <span class="n">points</span><span class="p">[:,</span> <span class="o">~</span><span class="n">accepted</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">accepted</span><span class="p">.</span><span class="nf">sum</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
         <span class="n">accepted</span> <span class="o">=</span> <span class="p">((</span><span class="n">points</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>Có thể thấy cách này có điểm yếu ở việc phải kiểm tra xem điểm sinh ra có bị từ chối hay không, do đó sẽ có một số lần lấy mẫu thừa ra. Cụ thể, trong trường hợp này khả năng bị từ chối là \(p=1-\pi/4 \approx 0.2146\). Ngoài ra, nó cũng khó khăn trong việc vectorize, khác với cách trên.</p>

      </d-article>

      <d-appendix>
        <d-footnote-list></d-footnote-list>
        <d-citation-list></d-citation-list>
      </d-appendix>

      <d-bibliography src="/assets/bibliography/"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;">
  <script>
    let giscusTheme = localStorage.getItem("theme");
    let giscusAttributes = {
        "src": "https://giscus.app/client.js",
        "data-repo": "vltanh/vltanh.github.io",
        "data-repo-id": "R_kgDOIk7rUA",
        "data-category": "Comments",
        "data-category-id": "DIC_kwDOIk7rUM4CTV2c",
        "data-mapping": "title",
        "data-strict": "1",
        "data-reactions-enabled": "1",
        "data-emit-metadata": "0",
        "data-input-position": "bottom",
        "data-theme": giscusTheme,
        "data-lang": "en",
        "crossorigin": "anonymous",
        "async": "",
    };


    let giscusScript = document.createElement("script");
    Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
    document.getElementById("giscus_thread").appendChild(giscusScript);
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a>
</noscript>
</div>
</div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2023 The-Anh  Vu-Le. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>.

      </div>
    </footer>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-JS11DTCF4Y"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-JS11DTCF4Y');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  
</body>
</html>
